def color_map = [
    'SUCCESS': 'good',
    'FAILURE': 'danger',
    'ABORTED': 'warning',
]

def emoji_map = [
    'SUCCESS': 'white_check_mark',
    'FAILURE': 'x',
    'ABORTED': 'heavy_multiplication_x',
]

def slackChannel = getSlackChannel()

def getSlackChannel() {
    if (params.messageThread == null) {
        return "s_test"        
    } else {
        return params.messageThread
    }
}

def getBuildUser() {
    try {
        return "User: *${currentBuild.rawBuild.getCause(Cause.UserIdCause).getUserId()}*"
    } catch(Exception e) {
        return ""
    }
}


pipeline{
    agent any

    stages{
        stage('Send slack notification') {
            steps {
                script {
                    def message = "Info: Start notifications test on Jenkins\n${env.BUILD_URL}\n${getBuildUser()}\n"

                    slackNotify = slackSend(channel: slackChannel, message: message)
                    slackChannel = slackNotify.threadId
                    def timestamp = slackNotify.ts
                }
            }
        }
        
        stage('Run Downstream'){
            steps{
                script{
                    sleep 3

                    build job: "Setrix/Production/test/downstream", parameters: [
                        string(name: 'messageThread', value: slackChannel)]

                }
            }
        }

        stage('Done upstream'){
            steps{
                script{
                    echo "Done upstream"
                }
            }
        }
    }

    post {
        always {
            script {
                def message = "Info: Ended build\nStatus: *${currentBuild.currentResult}*\n${env.BUILD_URL}\n${getBuildUser()}"

                slackSend(channel: slackChannel, message: message, timestamp: timestamp, color: color_map[currentBuild.currentResult])
                slackNotify.addReaction(emoji_map[currentBuild.currentResult])
            }
        }
    }
}
